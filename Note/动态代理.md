课件：
    抽象角色：指代理对象和真实对象对外提供的公共方法，一般为一个接口。
    真实角色：需要实现抽象角色接口，定义了真实角色所需实现的业务逻辑，以便供代理角色调用，也就是真正的业务逻辑在此。
    代理角色：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作，将统一的流程控制都放在代理角色中处理。
    静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类，一般来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。
    静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代理对象会出现拓展能力差的问题。

    
 代理模式类图
    Client: 调用者
    Interface: 为Interface抽象接口,定义Action()行为方法。
    ProxySubject:代理对象,实现抽象接口中的 Action()行为方法,代理RealSubject。
    RealSubject:真实对象,实现抽象接口中的 Action()行为方法 。


原理：Object proxyObject = Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), new Class[]{Purchase.class, Sale.class}, new InvocationHandler() {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
         return method.invoke(gw, args);//gw 需要代理的真实对象
    }
}); 
    

    在 Proxy.newProxyInstance 函数中，会通过反射创建代理对象。生成的代理class对象，包含一个构造函数，
    函数的参数为newProxyInstance方法传入的InvocationHandler。当调用代理class实例对象的方法时，就会回调这个InvocationHandler中的
    invoke函数。

    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h) throws IllegalArgumentException{
        Objects.requireNonNull(h);
        //获取接口Class数组集合
        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }
        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);
        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }
            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }

    Class<?> cl = getProxyClass0(loader, intfs);
    cl 这个Class对象是通过getProxyClass0(loader, intfs) 生成在内存当中的Class对象。
 
笔记：

总结：
    Retrofit 原理
    动态代理  注解  反射

面试题：

