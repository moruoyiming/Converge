课件：
    抽象角色：指代理对象和真实对象对外提供的公共方法，一般为一个接口。
    真实角色：需要实现抽象角色接口，定义了真实角色所需实现的业务逻辑，以便供代理角色调用，也就是真正的业务逻辑在此。
    代理角色：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作，将统一的流程控制都放在代理角色中处理。
    静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类，一般来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。
    静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代理对象会出现拓展能力差的问题。

    
 代理模式类图
    Client: 调用者
    Interface: 为Interface抽象接口,定义Action()行为方法。
    ProxySubject:代理对象,实现抽象接口中的 Action()行为方法,代理RealSubject。
    RealSubject:真实对象,实现抽象接口中的 Action()行为方法 。


原理：Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), new Class[]{Purchase.class, Sale.class}, new InvocationHandler() {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
         return method.invoke(gw, args);//gw 需要代理的真实对象
    }
});
    在 Proxy.newProxyInstance 函数中，会通过反射创建代理对象。
        
        Objects.requireNonNull(h);
        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }
        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);
        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
   

 
笔记：

总结：

面试题：

