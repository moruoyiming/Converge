课件：

笔记：

//        1.获取Activity的class对象
            Class<? extends Activity> clazz = activity.getClass();
//        2.判断当前Activity是否为InjectLayout修饰
            if (clazz.isAnnotationPresent(InjectLayout.class)) {
//        3.获取InjectLayout注解
            InjectLayout annotation = clazz.getAnnotation(InjectLayout.class);
                if (annotation != null) {
                    try {
//                    4.通过反射获取 当前Activity 的 setContentView 方法
                        Method method = clazz.getMethod("setContentView", int.class);
//                    5.获取注解上的value layoutId
                        int resourceId = annotation.value();
//                    6.调用setContentView
                        method.invoke(activity, resourceId);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                 }
            }

动态代理
        try {
//          1.获取Activity的class对象
              Class<? extends Activity> clazz = activity.getClass();
//          2.获取Activity的所有成员方法 排除继承方法
              Method[] methods = clazz.getDeclaredMethods();
              for (Method method : methods) {
//                3.是否是自定义注解修饰
                if (method.isAnnotationPresent(OnClick.class)) {//TODO OnLongClick事件处理
                    OnClick onClick = method.getAnnotation(OnClick.class);
                    int[] value = onClick.value();
//                4.获取注解上的注解 元注解
                    InjectEvent injectEvent = onClick.annotationType().getAnnotation(InjectEvent.class);
                    String listenerSetter = injectEvent.listenerSetter();
                    Class<?> listenerType = injectEvent.listenerType();
                    String methodName = injectEvent.methodName();
//                5.动态代理 生成代理的listener
                    ProxyHandler handler=new ProxyHandler(activity);
                    Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(),
                    new Class[]{listenerType}, handler);
                    handler.mapMethod(methodName,method);
//                6.反射获取 findViewById方法的Method对象
                    Method findViewByIdMethod = clazz.getMethod("findViewById", int.class);
                    findViewByIdMethod.setAccessible(true);
                    for (int id : value) {
//                7.通过findViewById获取view
                    View btn = (View) findViewByIdMethod.invoke(activity, id);
//                8.根据listenerSetter方法名和listenerType方法参数找到method
                    Method listenerSetMethod = btn.getClass().getMethod(listenerSetter, listenerType);
                    listenerSetMethod.setAccessible(true);
                    listenerSetMethod.invoke(btn, listener);
                    }
                }
            }


总结：
  1.反射几种：
    1.通过类名实现反射机制
    Class clz = Activity.class;    
    2.通过new对象实现反射机制
    Class<? extends Activity> clz = activity.getClass();
    3.通过路径实现反射机制
    Class<?> clazz = Class.forName("android.app.ActivityThread");
  2.获取某个Class对象的方法集合，主要有以下几个方法：
    //- getDeclaredMethods() 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。
    //- getMethods() 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。
    //- getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象
  3.如何设置方法、字段访问权限？
    .setAccessible(true);
面试题：
  1.getMethod、getDeclaredMethods 区别？
  2.如何设置方法、字段访问权限？
    .setAccessible(true);




反射与泛型会出现问题：
//Exception in thread "main" java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType
//	at com.example.converge.note.androidbasics.inject.Test$TypeRefrence.<init>(Test.java:43)
//	at com.example.converge.note.androidbasics.inject.Test.main(Test.java:75)
static class TypeRefrence<T> {
Type type;
        public TypeRefrence() {
            //获得泛型类型
            Type genericSuperclass = getClass().getGenericSuperclass();
            ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;
            //因为泛型可以定义多个A<T,E> 所以是个数组
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            type = actualTypeArguments[0];
        }

        public Type getType() {
            return type;
        }

        public void setType(Type type) {
            this.type = type;
        }
    }

//加{}表示成匿名内部类，不加{}会报错，TypeRefrence<>会有泛型擦出操作，导致字节码中找不到Response相关签名信息。
Type type2 = new TypeRefrence<Response<Data>>(){}.getType();
System.out.println("type2 "+type2);