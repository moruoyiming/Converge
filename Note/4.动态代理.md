课件：
    静态代理:
    目的:
       （1）通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性；
       （2）通过代理对象对访问进行控制；
    角色:
    抽象角色：指代理对象和真实对象对外提供的公共方法，一般为一个接口。
    真实角色：需要实现抽象角色接口，定义了真实角色所需实现的业务逻辑，以便供代理角色调用，也就是真正的业务逻辑在此。
    代理角色：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作，将统一的流程控制都放在代理角色中处理。

    静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类，一般来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。
    静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代理对象会出现拓展能力差的问题。

    代理模式类图
    Client: 调用者
    Interface: 为Interface抽象接口,定义Action()行为方法。
    ProxySubject:代理对象,实现抽象接口中的 Action()行为方法,代理RealSubject。
    RealSubject:真实对象,实现抽象接口中的 Action()行为方法 。


   动态代理:
    在运行时再创建代理类和其实例，因此显然效率更低。要完成这个场景，需要在运行期动态创建一个Class。
    实际上， Proxy.newProxyInstance 会创建一个Class，与静态代理不同，这个Class不是由具体的.java源文件编译而来，即没有真正的文件，
    只是在内存中按照Class格式生成了一个Class。

原理：Object proxyObject = Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), new Class[]{Purchase.class, Sale.class}, new InvocationHandler() {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
         return method.invoke(gw, args);//gw 需要代理的真实对象
    }
}); 
    

    在 Proxy.newProxyInstance 函数中，会通过反射创建代理对象。生成的代理class对象，包含一个构造函数，
    函数的参数为newProxyInstance方法传入的InvocationHandler。当调用代理class实例对象的方法时，就会回调这个InvocationHandler中的
    invoke函数。

    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h) throws IllegalArgumentException{
        Objects.requireNonNull(h);
        //获取接口Class数组集合
        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }
        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);
        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }
            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }

    Class<?> cl = getProxyClass0(loader, intfs);
    cl 这个Class对象是通过getProxyClass0(loader, intfs) 生成在内存当中的Class对象。
 
笔记：
    静态代理：
        优点：可以在不修改目标对象的前提下扩展目标对象的功能
        缺点：如果需要代理多个类，每个类都会有一个代理类，会导致代理类无限制扩展；如果类中有多个方法，同样的代理逻辑需要反复实现、应用到每个方法上，一旦接口增加方法，目标对象与代理对象都要进行修改
    动态代理：
        动态代理的关键点就是动态生成代理类。jdk通过 Proxy.newProxyInstance 创建动态代理类 。通过设置系统属性，把生成的代理类保存下来。
        代理类提供四个静态方法：
        1.getProxyClass
        getProxyClass 方法返回代理类的Class实例。这个代理类就是类加载器loader定义的、实现了一些列接口 interfaces的。如果之前已经为这个loader和interfaces创建过代理类，那么直接返回这个代理类的Class实例。如果没有，则动态创建并返回。
        2.newProxyInstance    
        newProxyInstance使用反射机制调用动态代理类的构造函数生成一个代理类实例的过程
        3.isProxyClass
        用于判断一个类是不是代理类。Proxy.class.isAssignableFrom(cl)这句话简而言之就是判断cl所表示的类是不是Proxy或者Proxy的子类。因为所有的代理类都集成Proxy，所以这个条件必须满足。满足这个条件也不能保证就是代理类，因为可能存在人
        为地编写一个类继承Proxy这种情况。proxyClassCache.containsValue(cl)这个方法是检查缓存中是否存在这个Class实例cl。我前面分析过，但凡生成的代理类都会被缓存，所以这个方法才是检测一个类是否是代理类的唯一标准。
        4.getInvocationHandler
        用于获取代理类中的InvocationHandler实例。这个方法没有什么太多的逻辑，基本就是判断下传入的对象是否是代理类，以及一些访问权限的校验。当这些都合法的情况下，返回InvocationHandler实例。
    字节码来源有两种路径：
    1.硬盘
    2.内存
      1.怎么样在内存中生成?
        在Proxy类中静态内部类ProxyClassFactory生成。ProxyClassFactory调用ProxyGenerator.generateProxyClass生成指定代理类。
      2.生成的.class文件结构?
        ProxyGenerator.generateProxyClass生成的代理类就是byte[]，然后在将这个byte[]通过native方法defineClass0生成class对象。

总结：
    Retrofit 原理
    动态代理、注解、反射
    设计模式:门面模式、构建者模式、动态代理模式、适配器模式。
    1.生命网络请求接口interface,内部包含 get post 请求。
    2.Retrofit通过构建者模式,build出retrofit对象。可以设置callFactory、addCallAdapterFactory、addConverterFactory等成员。
    3.Retrofit中create方法中通过动态代理创建interface代理对象，当调用接口时，回调InvocationHandler类中invoke函数。
    4.invoke函数中，动态解析method方法上的所有注解信息。ServiceMethod.Builder构建并缓存,serviceMethodCache。
    5.当调用接口方法时，生成完整网络请求链接及参数。返回一个 Call<ResponseBody>对象。
    6.OkHttpCall为Call的实现类， RealCall.newRealCall()执行call.enqueue(new Callback<ResponseBody>() {});
    7.OkHttpCall真正执行网络请求，并将结果返回给Retrofit。
    
    构建者模式: 将一个复杂对象的构建和他的表示分离，可以让使用者不必知道内部组成的细节。
面试题：

