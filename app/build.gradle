import org.apache.commons.io.IOUtils
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.MethodVisitor
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Type

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream

apply plugin: 'com.android.application'
apply plugin: 'com.alibaba.arouter'
// 引入自定义Gradle 插件方式
// 第一种方式 直接引入
//apply plugin:com.example.patch.PatchPlugin
// 第二种方式 带''，在buildSrc的main中创建resource/META-INF/gradle-plugins
apply plugin: 'com.example.patch'
//热修复代码
patch {
    debugOn true
    applicationName 'com.example.hotfix.MyApplication'
    output 'com.example.hotfix.MyApplication'
}


android {

    signingConfigs {
        debug {
            keyAlias RELEASE_KEY_ALIAS
            keyPassword RELEASE_KEY_PASSWORD
            storeFile file(RELEASE_STOREFILE)
            storePassword RELEASE_STORE_PASSWORD
        }
        release {
            keyAlias RELEASE_KEY_ALIAS
            keyPassword RELEASE_KEY_PASSWORD
            storeFile file(RELEASE_STOREFILE)
            storePassword RELEASE_STORE_PASSWORD
        }
    }

    compileSdkVersion rootProject.compileSdkVersion
    buildToolsVersion rootProject.buildToolsVersion
    defaultConfig {
        applicationId "com.example.hotfix"
        minSdkVersion rootProject.minSdkVersion
        targetSdkVersion rootProject.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        // Enabling multidex support.
        multiDexEnabled true

        externalNativeBuild {
            cmake {
                abiFilters 'x86', 'armeabi-v7a'
            }
        }

        ndk {
            abiFilters 'x86', 'armeabi-v7a'
        }

    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    buildFeatures {
        dataBinding true
    }

    buildTypes {
        debug {
            buildConfigField "boolean", "LOG_DEBUG", "true"
            minifyEnabled false
            zipAlignEnabled false
            shrinkResources false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.debug
        }

        release {
            buildConfigField "boolean", "LOG_DEBUG", "false"
            minifyEnabled true
            zipAlignEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }
    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.10.2"
        }
    }

    dexOptions {
        javaMaxHeapSize "4g"
    }

}


dependencies {
    implementation 'com.google.dagger:dagger:2.28.3'
    annotationProcessor 'com.google.dagger:dagger-compiler:2.16'
    api project(':news')
    api project(':aop')
    api project(':inject')
    implementation project(':arouter-annotations')
    implementation 'org.aspectj:aspectjrt:1.9.2'
}
tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}
repositories {
    mavenCentral()
}
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main

final def log = project.logger
final def variants = project.android.applicationVariants

variants.all { variant ->

//    if (!variant.buildType.isDebuggable()) {
//        log.debug("Skipping non-debuggable build type '${variant.buildType.name}'.")
//        return;
//    }

    JavaCompile javaCompile = variant.javaCompile

    javaCompile.doLast {

        String[] args = ["-showWeaveInfo",

                         "-1.8",

                         "-inpath", javaCompile.destinationDir.toString(),

                         "-aspectpath", javaCompile.classpath.asPath,

                         "-d", javaCompile.destinationDir.toString(),

                         "-classpath", javaCompile.classpath.asPath,

                         "-bootclasspath", project.android.bootClasspath.join(File.pathSeparator)]

        log.debug "ajc args: " + Arrays.toString(args)

        MessageHandler handler = new MessageHandler(true);

        new Main().run(args, handler);

        for (IMessage message : handler.getMessages(null, true)) {

            switch (message.getKind()) {

                case IMessage.ABORT:

                case IMessage.ERROR:

                case IMessage.FAIL:

                    log.error message.message, message.thrown

                    break;

                case IMessage.WARNING:

                    log.warn message.message, message.thrown

                    break;

                case IMessage.INFO:

                    log.info message.message, message.thrown

                    break;

                case IMessage.DEBUG:

                    log.debug message.message, message.thrown

                    break;
            }
        }
    }
}

//gradle执行会解析build.gradle文件，afterEvaluate表示在解析完成之后再执行我们的代码
afterEvaluate({
    android.getApplicationVariants().all {
        variant ->
            //获得: debug/release
            String variantName = variant.name
            //首字母大写 Debug/Release
            String capitalizeName = variantName.capitalize()
            for (Task task : project.getTasks()) {
                System.out.println("dexTask  : " + task.getName())
            }
            //这就是打包时，把jar和class打包成dex的任务
            Task dexTask =project.getTasks().findByName("transformClassesWithCom.alibaba.arouterForDebug" );
            //在他打包之前执行插桩
//            dexTask.doFirst {
//                //任务的输入，dex打包任务要输入什么？ 自然是所有的class与jar包了！
//                FileCollection files = dexTask.getInputs().getFiles()
//
//                for (File file : files) {
//                    System.out.println("file  : " + file + "  name " + file.getName())
//                    //.jar ->解压-》插桩->压缩回去替换掉插桩前的class
//                    // .class -> 插桩
//                    String filePath = file.getAbsolutePath();
//                    //依赖的库会以jar包形式传过来，对依赖库也执行插桩
//                    if (filePath.endsWith(".jar")) {
//                        processJar(file);
//
//                    } else if (filePath.endsWith(".class")) {
//                        //主要是我们自己写的app模块中的代码
//                        processClass(variant.getDirName(), file);
//                    }
//                }
//            }
    }
})


static boolean isAndroidClass(String filePath) {
    return filePath.startsWith("android") ||
            filePath.startsWith("androidx");
}

static byte[] referHackWhenInit(InputStream inputStream) throws IOException {
    // class的解析器
    ClassReader cr = new ClassReader(inputStream)
    // class的输出器
    ClassWriter cw = new ClassWriter(cr, 0)
    // class访问者，相当于回调，解析器解析的结果，回调给访问者
    ClassVisitor cv = new ClassVisitor(Opcodes.ASM5, cw) {

        //要在构造方法里插桩 init
        @Override
        public MethodVisitor visitMethod(int access, final String name, String desc,
                                         String signature, String[] exceptions) {

            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
            mv = new MethodVisitor(Opcodes.ASM5, mv) {
                @Override
                void visitInsn(int opcode) {
                    //在构造方法中插入AntilazyLoad引用
                    if ("<init>".equals(name) && opcode == Opcodes.RETURN) {
                        //引用类型
                        //基本数据类型 : I J Z
                        super.visitLdcInsn(Type.getType("Lcom/com/example/hack/AntilazyLoad;"));
                    }
                    super.visitInsn(opcode);
                }
            };
            return mv;
        }

    };
    //启动分析
    cr.accept(cv, 0);
    return cw.toByteArray();
}

/**
 * linux/mac: /xxxxx/app/build/intermediates/classes/debug/com/enjoy/qzonefix/MainActivity.class
 * windows: \xxxxx\app\build\intermediates\classes\debug\com\enjoy\qzonefix\MainActivity.class
 * @param file
 * @param hexs
 */
static void processClass(String dirName, File file) {

    String filePath = file.getAbsolutePath();
    //注意这里的filePath包含了目录+包名+类名，所以去掉目录
    String className = filePath.split(dirName)[1].substring(1);
    //application或者android support我们不管
    if (className.startsWith("com\\example\\hotfix\\MyApplication") || isAndroidClass(className)) {
        return
    }

    try {
        // byte[]->class 修改byte[]
        FileInputStream is = new FileInputStream(filePath);
        //执行插桩  byteCode:插桩之后的class数据，把他替换掉插桩前的class文件
        byte[] byteCode = referHackWhenInit(is);
        is.close();

        FileOutputStream os = new FileOutputStream(filePath)
        os.write(byteCode)
        os.close()
    } catch (Exception e) {
        e.printStackTrace();
    }
}
//HotFix.test();

static void processJar(File file) {
    try {
        //  无论是windows还是linux jar包都是 /
        File bakJar = new File(file.getParent(), file.getName() + ".bak");
        JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(bakJar));

        JarFile jarFile = new JarFile(file);
        Enumeration<JarEntry> entries = jarFile.entries();
        while (entries.hasMoreElements()) {
            JarEntry jarEntry = entries.nextElement();

            // 读jar包中的一个文件 ：class
            jarOutputStream.putNextEntry(new JarEntry(jarEntry.getName()));
            InputStream is = jarFile.getInputStream(jarEntry);

            String className = jarEntry.getName();
            if (className.endsWith(".class") && !className.startsWith
                    ("com/example/hotfix/MyApplication")
                    && !isAndroidClass(className) && !className.startsWith("com/example" +
                    "/patch")) {
                byte[] byteCode = referHackWhenInit(is);
                jarOutputStream.write(byteCode);
            } else {
                //输出到临时文件
                jarOutputStream.write(IOUtils.toByteArray(is));
            }
            jarOutputStream.closeEntry();
        }
        jarOutputStream.close();
        jarFile.close();
        file.delete();
        bakJar.renameTo(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
}