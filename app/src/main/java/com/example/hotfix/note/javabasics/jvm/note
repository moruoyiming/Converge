    Java 运行过程

    HelloWorld.java -->javac编译 --> HelloWorld.class --> Java类加载器ClassLoad加载 -->
    JVM 运行时数据区 --> 执行引擎 --> 解析执行 --> 操作系统接口

    运行时数据区域
          线程私有  虚拟机栈、本地方法栈、程序计数器
          线程共享  方法区、堆

    程序计数器：指向当前线程正在执行的字节码指令地址。不会发生OOM
    虚拟机栈：存储当前线程运行方法所需的数据，指令、返回地址。子弹夹  先进后出
      栈帧：局部变量表
            操作数栈
            动态连接
            完成出口
      大小限制 -Xss
      局部变量表：存储局部变量，只能存储八大基础数据类型 + 引用
        操作数栈：存放方法执行、操作
        动态连接：Person p = new Man
                 p.wc()
                 Person p = new WoMan
                 p.wc()
        完成出口:方法执行后的返回值
    本地方法栈：本地方法栈保存的是native方法的信息
    当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中 创建栈帧，JVM只是简单地动态链接并直接调用native方法



    方法区：类信息、常量、静态变量、即时编译期编译后的代码
    Java堆： 对象实例、数组


    直接内存
    不是虚拟机运行时数据区的一部分，也不是java虚拟 机规范中定义的内存区域;
    如果使用了NIO,这块区域会被频繁使用，在java堆内可 以用directByteBuffer对象直接引用并操作;
    这块内存不受java堆大小限制，但受本机总内存的限制 ，可以通过MaxDirectMemorySize来设置(默认与堆内 存最大值一样)，
    所以也会出现OOM异常;


    类加载 -> 检查加载 -> 分配内存 -> 内存空间初始化 -> 设置 -> 对象初始化

    分配内存
     内存划分:指针碰撞、空闲列表
     线程安全问题：cas操作
     内存划分的方式取决堆规整程度

    堆规整程度  连续   或   分散 。
     堆规整程度取决垃圾回收器的算法。

    垃圾收集器  是否带整理（压缩）功能

    内存回收算法
      标记清除、标记整理

    类加载过程   加载->验证->准备->解析->初始化->使用->卸载
    加载：
    验证：
    准备：
    解析：
    初始化：
    使用：
    卸载：

    对象占据内存一定是连续。

    并发安全问题
     CAS
     本地线程分配缓冲 TLAB Thread Local Allocation Buffer  分配在Eden区

    什么时候CAS 什么时候TLAB ？


    逃逸分析原理：分析对象动态作用域。
    如果逃逸。对象不可以分配在栈上。
    如果没有逃逸，可以在栈上分配内存。

    方法逃逸：方法返回参数，给其他方法使用称之方法逃逸。
    线程逃逸：被外部线程访问，赋值操作称之为线程逃逸。



    1.类加载过程
    　　首先，jvm在执行时，遇到一个新的类时，会到内存中的方法区去找class文件，如果找到就直接拿来用，
    如果没有找到，就会到硬盘中去找到这个class文件，将类文件加载到方法区，在类加载时，静态成员变量加载
    到方法区的静态区域，非静态成员变量加载到方法区的非静态区域，加载静态成员变量的时候，会根据书写的顺序，
    将所有的静态成员变量加载到静态方法区，然后给所有的静态成员变量赋默认值，赋默认值后，会根据静态成员
    变量书写的位置，给静态成员变量赋显示值，和执行静态代码。当执行完所有的静态代码块时，类才算加载完成。

    类加载过程：
    1.JVM会先去方法区中找有没有相应类的.class存在。如果有，就直接使用；如果没有，则把相关类的.class加载到方法区。
    2.在.class加载到方法区时，会分为两部分加载：先加载非静态内容，在加载静态内容。
    3.在加载非静态内容：把.class中的所有非静态内容加载到方法区下的非静态区域内
    4.加载静态内容：
       4.1把.class中所有静态内容加载到方法区下的静态区域内。
       4.2静态内容加载完成之后，对所有的静态变量进行默认初始化。
       4.3所有的静态变量默认初始化完成之后，再进行显示初始化。
       4.4当静态区域下的所有静态变量显示初始化完后，执行静态代码块。
    5.当静态区域下的静态代码块，执行完之后，整个类的加载就完成了。

    2.对象创建过程：
    1.在堆内存中开辟一块空间。
    2.给开辟空间分配一个地址。
    3.把对象的所有非静态成员加载到所开辟的空间下。
    4.所有的非静态成员加载完成之后，对所有非静态成员变量进行默认初始化。
    5.所有非静态成员变量默认初始化完成之后，调用构造函数。
    6.在构造函数入栈执行时，分为两部分：先执行构造函数中的隐式三步，在执行构造函数中书写的代码。
       6.1隐式三步：
    　　1.执行super语句
    　　2.对开辟空间下的所有非静态成员变量进行显示初始化
    　　3.执行构造代码块
    　6.2在隐式三步执行完之后，执行构造函数中书写的代码
    7.在整个构造函数执行完并弹栈后，把空间分配的地址赋值给一个引用对象





    2. 类加载时机

        加载（loading）阶段，java虚拟机规范中没有进行约束，但初始化阶段，java虚拟机严格规定了有且只有如下5种情况必须立即进行初始化（初始化前，必须经过加载、验证、准备阶段）：

        （1）使用new实例化对象时，读取和设置类的静态变量、静态非字面值常量（静态字面值常量除外）时，调用静态方法时。

        （2）对内进行反射调用时。

        （3）当初始化一个类时，如果父类没有进行初始化，需要先初始化父类。

        （4）启动程序所使用的main方法所在类

        （5）当使用1.7的动态语音支持时。

        如上5种场景又被称为主动引用，除此之外的引用称为被动引用，被动引用有如下3种常见情况

    通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
    定义对象数组和集合，不会触发该类的初始化
    类A引用类B的static final常量不会导致类B初始化（注意静态常量必须是字面值常量，否则还是会触发B的初始化）

    通过类名获取Class对象，不会触发类的初始化。如System.out.println(Person.class);
    通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化。
    通过ClassLoader默认的loadClass方法，也不会触发初始化动作
        注意：被动引用不会导致类初始化，但不代表类不会经历加载、验证、准备阶段。

    3. 类加载方式

        这里的类加载不是指类加载阶段，而是指整个类加载过程，即类加载阶段到初始化完成。

    （1）隐式加载

        创建类对象
        使用类的静态域
        创建子类对象
        使用子类的静态域
        在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class
        在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class
        在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件
    （2）显式加载

        ClassLoader.loadClass(className)，只加载和连接、不会进行初始化
        Class.forName(String name, boolean initialize,ClassLoader loader);
        使用loader进行加载和连接，根据参数initialize决定是否初始化。

    2. 加载阶段
        加载是类加载过程中的一个阶段，不要将这2个概念混淆了。

        在加载阶段，虚拟机需要完成以下3件事情：

    通过一个类的全限定名来获取定义此类的二进制字节流
    将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
        加载.class文件的方式

    从本地系统中直接加载
    通过网络下载.class文件
    从zip，jar等归档文件中加载.class文件
    从专有数据库中提取.class文件
    将Java源文件动态编译为.class文件
        相对于类生命周期的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

    3. 连接阶段
      3.1 验证：确保被加载的类的正确性

        确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

    文件格式验证：验证字节流是否符合Class文件格式的规范，如：是否以模数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。
    元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。
    字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，如：操作数栈的数据类型与指令代码序列能配合工作，保证方法中的类型转换有效等等。
    符号引用验证：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等。
        验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施。

      3.2 准备：为类的静态变量分配内存，并将其赋默认值

        为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

    只对static修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。
    对final的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）。
      3.3 解析：将常量池中的符号引用替换为直接引用（内存地址）的过程

        符号引用就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

        直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针。

        假设：一个类有一个静态变量，该静态变量是一个自定义的类型，那么经过解析后，该静态变量将是一个指针，指向该类在方法区的内存地址。 具体见后续文章。

    4. 初始化：为类的静态变量赋初值
        赋初值两种方式：

    定义静态变量时指定初始值。如 private static String x="123";
    在静态代码块里为静态变量赋值。如 static{ x="123"; }
        注意：只有对类的主动使用才会导致类的初始化。

    5. clinit 与 init
        在编译生成class文件时，编译器会产生两个方法加于class文件中，一个是类的初始化方法clinit, 另一个是实例的初始化方法init。

      5.1 clinit

        clinit指的是类构造器，主要作用是在类加载过程中的初始化阶段进行执行，执行内容包括静态变量初始化和静态块的执行。

        注意事项：

        1. 如果类中没有静态变量或静态代码块，那么clinit方法将不会被生成。

        2. 在执行clinit方法时，必须先执行父类的clinit方法。

        3. clinit方法只执行一次。

        3. static变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定。

