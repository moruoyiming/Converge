Thread 底层调用start的 native方法
并行 及 并发 概念？
并行，多个线程同时执行的概念。
并发，单位时间内，线程处理数据的能力，吞吐量。

Java默认是多线程
高并发编程的意义及好处？
平衡使用我们的线程(好处)
不要cpu 过累(意义)

非守护线程  主线程 和 子线程
 主线程结束，子线程不会直接结束 一直在等Thead t 到底执行完了没有
守护线程
 主线程结束，子线程跟着结束。因为子线程是守护线程。


面试题
1.run 和start方法的区别？
   .run()时函数调用和线程没有任何关系，.start()方法执行native底层函数，系统最终调度到run函数，这才是线程。
2. 如何控制线程的执行顺序？
   .join() 函数控制，让t2获取执行权力，能够做到顺序执行
3. 多线程中的并行和并发是什么？
   四个车道，四辆车并行的行驶，就是并行。
   四个车道，五秒钟多少的车流量，多少的吞吐量，是并发。单位时间内的执行效率
4. 在Java中能不能指定CPU去执行某个线程？
   不能，Java是做不到的，唯一能够去干预的是C语言调用内核的API去执行才行。
5. 项目开发过程中，你会考虑线程优先级么？
   不会考虑优先级，为什么呢？因为线程的优先级很依赖与系统的平台，所以这个优先级无法对号入座，无法做到你想象中的优先级，属于
   不稳定，有风险，因为某些开源框架，也不能依靠线程优先级来设置自己想要的优先级顺序，这个是不可靠的。
   例：Java线程优先级有十级，而此时操作系统优先级指有2~3级，那就对应不上了。
6. sleep 和 wait 有什么区别？
   sleep是休眠，等休眠时间一国，才有执行的资格，注意是有资格，并不能马上就会被执行，什么时候执行，取决于cpu系统调度。
   wait是登台，需要唤醒，唤醒后，才有执行的资格。
   sleep()：线程进入睡眠状态，不会释放锁
   wait()：调动方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁
   含义不同: sleep 无条件可以休眠， wait是某些原因与条件 需要等待一下。
7. 在Java中能不能强制中断线程的执行
   虽然提供了stop函数，但是此函数不推荐使用。因为这种方式很暴力，很危险，例如:下载图片5kb，只下载了4kb等我们可以使用interrupt来
   处理我线程的停止，但是注意interrupt只是协作式的方式，并不能绝对保证终中断，并不是抢占式。
8. 如何让出当前线程的执行权？
   yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行
9. notify()和notifyAll()区别？
       notify()可能发生信号丢失的情况。并且可能会导致死锁现象。
       锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(
       或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，
       但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
       等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中
   如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
   当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），
   被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，
   而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争
   优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，
   它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，
   这时锁池中的线程会继续竞争该对象锁。
   唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争
   ，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。

10.调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？
   yield()：让出时间片，不会释放锁
   sleep()：线程进入睡眠状态，不会释放锁
   wait()：调动方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁
   notify()：调动方法之前，必须要持有锁，调用notify()方法本身不会释放锁的。而是通知等待队列中的某一个线程，同步代码块执行完毕后才会释放锁
   notifyAll()：同notify，有一点不同在于，notifyAll会发出n个信号（n=等待线程数），而notify只会发出一个信号，通常情况下，尽量选择notifyAll
11.join()函数作用？
   线程A，执行了线程B的join方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作
12.sleep 和 wait 哪个函数才会清除interrupt中断标记？
   sleep 在抛出异常的时候，捕获异常之前就已经清除中断标记。


   sleep 会将中断信号 interrupt()  指令清除。

