Java内存模型
JMM内存模型

JMM内存模型
工作内存每个线程独享。工作内存要操作一个变量，会从主内存读取变量在自己的工作内存中放一份单独的副本。不允许工作线程直接访问
主内存，也不能访问其他线程的内存。


主内存
工作内存

从主内存中读取  每个java 线程中 都会有一个单独的内存副本。

count = count + 1

可见性：线程A、B之间工作内存存在可见性问题(volatile解决)
原子性 累加操作不是原子操作。在上下文切换时会被打断，

volatile只能保证可见性，无法保证原子性。轻量级同步机制。禁止指令重排序。
volatile变量修改后，强制更新到主存。其他线程

流水线和指令重排序。
多条指令

intel 十级流水线
ARM架构 三级流水线

volatile + cas操作 替代 Synchronized关键字

volatile的实现原理
volatile关键字修饰的变量会存在一个“lockTest:”的前缀。
Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。
同时该指令会将当前处理器缓存行的数据直接写回到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。



